# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ChizuXMLLoader
                                 A QGIS plugin
 loading xml file from GSI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-02
        git sha              : $Format:%H$
        copyright            : (C) 2024 by kirishima
        email                : ctkirishima@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QDockWidget

from qgis.core import QgsVectorLayer, QgsProject, QgsCoordinateReferenceSystem
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .chizu_XML_loader_dialog import ChizuXMLLoaderDialog
import os.path

import os
import sys
import time
import xml.etree.ElementTree as ET

class ChizuXMLLoader:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ChizuXMLLoader_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&chizu_XML_loader')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ChizuXMLLoader', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/chizu_XML_loader/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'chizu_XML_loader'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&chizu_XML_loader'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ChizuXMLLoaderDialog(self.iface.mainWindow())

            self.dlg.pushButton.clicked.connect(self.get_xml_file)
            self.dlg.pushButton_2.clicked.connect(self.get_xml_dir)
            self.dlg.pushButton_3.clicked.connect(self.run_make_layer)

            self.dlg.buttonGroup.buttonClicked.connect(self.change_radio_button)

        self.change_radio_button()
        self.dlg.show()


    def get_xml_file(self):
        file_path, _ = QFileDialog.getOpenFileName(filter="XML files (*.xml)")
        self.dlg.lineEdit.setText(file_path)

    def get_xml_dir(self):
        dir_path = QFileDialog.getExistingDirectory()
        self.dlg.lineEdit_2.setText(dir_path)

    def change_radio_button(self):
        if self.dlg.radioButton.isChecked():
            self.dlg.lineEdit.setEnabled(True)
            self.dlg.pushButton.setEnabled(True)
            self.dlg.lineEdit_2.setEnabled(False)
            self.dlg.pushButton_2.setEnabled(False)
        else:
            self.dlg.lineEdit.setEnabled(False)
            self.dlg.pushButton.setEnabled(False)
            self.dlg.lineEdit_2.setEnabled(True)
            self.dlg.pushButton_2.setEnabled(True)

    def run_make_layer(self):
        pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        if not pythonConsole or not pythonConsole.isVisible():
            self.iface.actionShowPythonDialog().trigger()

        header_text = "筆id,大字コード,丁目コード,小字コード,予備コード,大字名,丁目名,小字名,予備名,地番,wkt,精度区分,座標値種別,筆界未定構成筆\n"

        if self.dlg.radioButton.isChecked():
            file_path = self.dlg.lineEdit.text()
            if not file_path:
                return
            xml_list = [file_path]
            dir_path = os.path.dirname(file_path)

        elif self.dlg.radioButton_2.isChecked():
            dir_path = self.dlg.lineEdit_2.text()
            if not dir_path:
                return
            file_list = os.listdir(dir_path)#ファイルのリストを作成
            #拡張子がxmlのファイルだけ選んでxml_list[]に格納

            xml_list=[]
            for file in file_list:
                if os.path.splitext(file)[1]==".xml":
                    xml_list+=[dir_path+"/"+file]

        else:
            return



        all_text=header_text
        for xml_path in xml_list:
            print("処理中_{}".format(xml_path))
            tree = ET.parse(xml_path)#xml読込
            root = tree.getroot()
            xmlns="{http://www.moj.go.jp/MINJI/tizuxml}"#ハードコーディング丸出しなので修正対象
            zmn="{http://www.moj.go.jp/MINJI/tizuzumen}"#ハードコーディング丸出しなので修正対象

            geom_info = root.find(xmlns+'空間属性')
            #点と線とポリゴンをそれぞれ取得
            p_id=geom_info.findall(zmn+'GM_Point')#ポイントのIDのリスト
            c_id=geom_info.findall(zmn+'GM_Curve')#ラインのIDのリスト
            f_id=geom_info.findall(zmn+'GM_Surface')#ポリゴンのIDのリスト
            #IDと実際の座標を紐付けるための辞書をそれぞれ用意
            p_dict={}
            c_dict={}
            f_dict={}

            #ポイントのIDとポイントの座標を紐付け
            for p in p_id:
                xite=p.iter(zmn+'Y')
                yite=p.iter(zmn+'X')
                x=next(xite)
                y=next(yite)
                p_dict[p.attrib["id"]]=x.text+" "+y.text

            #ラインのIDとラインを構成する座標もしくはポイントのIDを紐付け
            for c in c_id:
                #座標で指定されてる場合はこっち
                x_ite=c.iter(zmn+'Y')
                y_ite=c.iter(zmn+'X')
                try:
                    fx=next(x_ite)
                    sx=next(x_ite)
                    fy=next(y_ite)
                    sy=next(y_ite)
                    c_dict[c.attrib["id"]]=fx.text+" "+fy.text+","+sx.text+" "+sy.text
                except StopIteration:
                    pass

                #ポイントのIDで指定されてる場合はこっち
                c_ite=c.iter(zmn+'GM_PointRef.point')
                try:
                    farst=next(c_ite)
                    end=next(c_ite)
                    c_dict[c.attrib["id"]]=p_dict[farst.attrib["idref"]]+","+p_dict[end.attrib["idref"]]
                except StopIteration:
                    pass

            #ポリゴンのIDとポリゴンを構成するラインのIDを紐付け
            for f in f_id:
                #リングをリストで取得
                ring_ite=f.iter(zmn+'GM_Ring')

                #リングの中にポリゴンの情報を詰める
                all_ring=""
                for ring in ring_ite:
                    one_ring=""
                    # ラインは始点と終点の座標を持っているのでラインをそのまま繋げると
                    # 先のラインの終点と後のラインの始点が重複する
                    # というわけで一番最初のライン以外は終点のみ拾っていく
                    for fc in ring:
                        if not one_ring:
                            one_ring=c_dict[fc.attrib["idref"]]+","
                        else:
                            cp_list=c_dict[fc.attrib["idref"]].split(',')
                            one_ring+=cp_list[1]+","
                    one_ring=one_ring[:-1]
                    all_ring+="("+one_ring+"),"# 完成したリングをポリゴンジオメトリに追加
                all_ring=all_ring[:-1]# 最後のコンマは不要なので消す
                # できたポリゴンジオメトリを辞書に登録
                f_dict[f.attrib["id"]]='"POLYGON ('+all_ring+')"'


            elem = root.find(xmlns+'主題属性')
            hude_list= elem.findall(xmlns+'筆')
            zukaku_list = root.findall(xmlns+'図郭')
            zukaku_dict={}

            for zukaku in zukaku_list:
                map_number=zukaku.find(xmlns+'地図番号').text
                zukaku_hude_list=zukaku.findall(xmlns+'筆参照')
                for zukaku_hude in zukaku_hude_list:
                    hude_number=zukaku_hude.attrib["idref"]
                    if hude_number in zukaku_dict:
                        zukaku_dict[hude_number]=zukaku_dict[hude_number]+map_number+";"
                    else:
                        zukaku_dict[hude_number]=map_number+";"


            save_text=header_text


            for hude in hude_list:
                row_text=""

                try:
                    row_text+=hude.attrib["id"]+","#筆id
                except:
                    row_text+=","

                try:
                    ooaza_code=hude.find(xmlns+'大字コード')
                    row_text+=ooaza_code.text+","#大字コード
                except:
                    row_text+=","

                try:
                    choume_code=hude.find(xmlns+'丁目コード')
                    row_text+=choume_code.text+","#丁目コード
                except:
                    row_text+=","

                try:
                    koaza_code=hude.find(xmlns+'小字コード')
                    row_text+=koaza_code.text+","#小字コード
                except:
                    row_text+=","

                try:
                    yobi_code=hude.find(xmlns+'予備コード')
                    row_text+=yobi_code.text+","#予備コード
                except:
                    row_text+=","

                try:
                    ooaza_name=hude.find(xmlns+'大字名')
                    row_text+=ooaza_name.text+","#大字名
                except:
                    row_text+=","

                try:
                    choume_name=hude.find(xmlns+'丁目名')
                    row_text+=choume_name.text+","#丁目名
                except:
                    row_text+=","

                try:
                    koaza_name=hude.find(xmlns+'小字名')
                    row_text+=koaza_name.text+","#小字名
                except:
                    row_text+=","

                try:
                    yobi_name=hude.find(xmlns+'予備名')
                    row_text+=yobi_name.text+","#予備名
                except:
                    row_text+=","
                try:
                    disp_num=hude.find(xmlns+'地番')
                    dnt = disp_num.text
                    row_text += dnt+","#表示地番
                except:
                    dnt=""
                    row_text+=","

                try:
                    f_id=hude.find(xmlns+'形状')
                    row_text+=f_dict[f_id.attrib["idref"]]+","#wkt
                except:
                    row_text+=","


                try:
                    ooaza_name=hude.find(xmlns+'精度区分')
                    row_text+=ooaza_name.text+",," # 座標精度
                except:
                    row_text+=","

                    try:
                        ooaza_name=hude.find(xmlns+'座標値種別')
                        row_text+=ooaza_name.text+"," # 座標精度
                    except:
                        row_text+=","

                try:
                    mitei_list=hude.findall(xmlns+'筆界未定構成筆')
                    mitei_text="\""
                    c_text = ""
                    if len(mitei_list)>0: # 構成筆が有る場合
                        for mitei in mitei_list:
                            c_text = "["

                            try:
                                mitei_ooaza_code=mitei.find(xmlns+'大字コード')
                                c_text+=mitei_ooaza_code.text+";"#大字コード
                            except:
                                c_text+=";"

                            try:
                                mitei_choume_code=mitei.find(xmlns+'丁目コード')
                                c_text+=mitei_choume_code.text+";"#丁目コード
                            except:
                                c_text+=";"

                            try:
                                mitei_koaza_code=mitei.find(xmlns+'小字コード')
                                c_text+=mitei_koaza_code.text+";"#小字コード
                            except:
                                c_text+=";"

                            try:
                                mitei_yobi_code=mitei.find(xmlns+'予備コード')
                                c_text+=mitei_yobi_code.text+";"#予備コード
                            except:
                                c_text+=";"

                            try:
                                mitei_ooaza_name=mitei.find(xmlns+'大字名')
                                c_text+=mitei_ooaza_name.text+";"#大字名
                            except:
                                c_text+=";"

                            try:
                                mitei_choume_name=mitei.find(xmlns+'丁目名')
                                c_text+=mitei_choume_name.text+";"#丁目名
                            except:
                                c_text+=";"

                            try:
                                mitei_koaza_name=mitei.find(xmlns+'小字名')
                                c_text+=mitei_koaza_name.text+";"#小字名
                            except:
                                c_text+=";"

                            try:
                                mitei_yobi_name=mitei.find(xmlns+'予備名')
                                c_text+=mitei_yobi_name.text+";"#予備名
                            except:
                                c_text+=";"

                            ch_text = mitei.find(xmlns+'地番').text
                            if "V" in ch_text:
                                ch_text = ch_text[:ch_text.index("V")]
                            elif "W" in ch_text:
                                ch_text = ch_text[:ch_text.index("W")]
                            elif "Ｖ" in ch_text:
                                ch_text = ch_text[:ch_text.index("Ｖ")]
                            elif "Ｗ" in ch_text:
                                ch_text = ch_text[:ch_text.index("Ｗ")]
                            else:pass

                            c_text += ch_text + "]"

                            mitei_text += c_text+"+"
                        mitei_text = mitei_text[:-1]+"\""
                    else: # 構成筆タグがなければ表示地番からVW除去して構成地番にする
                        c_text = "["

                        try:
                            c_text+=ooaza_code.text+";"#大字コード
                        except:
                            c_text+=";"

                        try:
                            c_text+=choume_code.text+";"#丁目コード
                        except:
                            c_text+=";"

                        try:
                            c_text+=koaza_code.text+";"#小字コード
                        except:
                            c_text+=";"

                        try:
                            c_text+=yobi_code.text+";"#予備コード
                        except:
                            c_text+=";"

                        try:
                            c_text+=ooaza_name.text+";"#大字名
                        except:
                            c_text+=";"

                        try:
                            c_text+=choume_name.text+";"#丁目名
                        except:
                            c_text+=";"

                        try:
                            c_text+=koaza_name.text+";"#小字名
                        except:
                            c_text+=";"



                        ch_text = dnt[:]
                        if "V" in ch_text:
                            ch_text = ch_text[:ch_text.index("V")]
                        elif "W" in ch_text:
                            ch_text = ch_text[:ch_text.index("W")]
                        elif "Ｖ" in ch_text:
                            ch_text = ch_text[:ch_text.index("Ｖ")]
                        elif "Ｗ" in ch_text:
                            ch_text = ch_text[:ch_text.index("Ｗ")]

                        c_text+=ch_text+"]"
                        mitei_text += c_text+"\""

                    row_text+=mitei_text+"\n" # 構成地番

                except:
                    print("error_2")
                    row_text+="\"\"\n"


                save_text += row_text
                all_text += row_text

            if self.dlg.radioButton.isChecked():
                save_csv = os.path.splitext(xml_path)[0]+".csv"
                layer_name = os.path.splitext(os.path.basename(xml_path))[0]
                with open(save_csv, 'w', encoding='shift_JIS') as f:
                    f.write(save_text)

        if self.dlg.radioButton_2.isChecked():
            save_csv = dir_path+"\\" + os.path.basename(dir_path) + ".csv"
            layer_name = os.path.basename(dir_path)
            with open(save_csv, 'w', encoding='shift_JIS') as f:
                f.write(all_text)

        text = self.dlg.comboBox.currentText()
        if text == "プロジェクトの座標系に従う":
            crs = QgsProject.instance().crs()

        else:
            crs_code = text[-4:]
            crs = QgsCoordinateReferenceSystem("EPSG:"+crs_code)


        layer = QgsVectorLayer(save_csv, layer_name, 'ogr')
        layer.setCrs(crs)
        fields = layer.fields()

        new_layer = QgsVectorLayer("Polygon", layer_name, 'memory')
        new_layer.startEditing()
        new_layer.setCrs(crs)

        new_layer.dataProvider().addAttributes(fields)
        new_layer.updateFields()
        new_layer.commitChanges()

        new_layer.startEditing()
        feats = layer.getFeatures()
        new_layer.addFeatures(feats)
        new_layer.commitChanges()

        new_layer.startEditing()
        idx = new_layer.fields().indexFromName('wkt')
        new_layer.deleteAttributes([idx])
        new_layer.commitChanges()

        QgsProject.instance().addMapLayer(new_layer)






